{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _jsxFileName = \"C:\\\\Users\\\\na2tt\\\\Desktop\\\\homework\\\\Recipe_App\\\\node_modules\\\\react-native\\\\Libraries\\\\Components\\\\ScrollView\\\\ScrollViewStickyHeader.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar AnimatedImplementation = require('../../Animated/src/AnimatedImplementation');\n\nvar React = require('react');\n\nvar StyleSheet = require('../../StyleSheet/StyleSheet');\n\nvar View = require('../View/View');\n\nvar AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\nvar ScrollViewStickyHeader = function (_React$Component) {\n  _inherits(ScrollViewStickyHeader, _React$Component);\n\n  var _super = _createSuper(ScrollViewStickyHeader);\n\n  function ScrollViewStickyHeader() {\n    var _this;\n\n    _classCallCheck(this, ScrollViewStickyHeader);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.state = {\n      measured: false,\n      layoutY: 0,\n      layoutHeight: 0,\n      nextHeaderLayoutY: _this.props.nextHeaderLayoutY\n    };\n\n    _this._onLayout = function (event) {\n      _this.setState({\n        measured: true,\n        layoutY: event.nativeEvent.layout.y,\n        layoutHeight: event.nativeEvent.layout.height\n      });\n\n      _this.props.onLayout(event);\n\n      var child = React.Children.only(_this.props.children);\n\n      if (child.props.onLayout) {\n        child.props.onLayout(event);\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(ScrollViewStickyHeader, [{\n    key: \"setNextHeaderY\",\n    value: function setNextHeaderY(y) {\n      this.setState({\n        nextHeaderLayoutY: y\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          inverted = _this$props.inverted,\n          scrollViewHeight = _this$props.scrollViewHeight;\n      var _this$state = this.state,\n          measured = _this$state.measured,\n          layoutHeight = _this$state.layoutHeight,\n          layoutY = _this$state.layoutY,\n          nextHeaderLayoutY = _this$state.nextHeaderLayoutY;\n      var inputRange = [-1, 0];\n      var outputRange = [0, 0];\n\n      if (measured) {\n        if (inverted) {\n          if (scrollViewHeight != null) {\n            var stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n\n            if (stickStartPoint > 0) {\n              inputRange.push(stickStartPoint);\n              outputRange.push(0);\n              inputRange.push(stickStartPoint + 1);\n              outputRange.push(1);\n              var collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n\n              if (collisionPoint > stickStartPoint) {\n                inputRange.push(collisionPoint, collisionPoint + 1);\n                outputRange.push(collisionPoint - stickStartPoint, collisionPoint - stickStartPoint);\n              }\n            }\n          }\n        } else {\n          inputRange.push(layoutY);\n          outputRange.push(0);\n\n          var _collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n\n          if (_collisionPoint >= layoutY) {\n            inputRange.push(_collisionPoint, _collisionPoint + 1);\n            outputRange.push(_collisionPoint - layoutY, _collisionPoint - layoutY);\n          } else {\n            inputRange.push(layoutY + 1);\n            outputRange.push(1);\n          }\n        }\n      }\n\n      var translateY = this.props.scrollAnimatedValue.interpolate({\n        inputRange: inputRange,\n        outputRange: outputRange\n      });\n      var child = React.Children.only(this.props.children);\n      return React.createElement(AnimatedView, {\n        collapsable: false,\n        onLayout: this._onLayout,\n        style: [child.props.style, styles.header, {\n          transform: [{\n            translateY: translateY\n          }]\n        }],\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 144,\n          columnNumber: 7\n        }\n      }, React.cloneElement(child, {\n        style: styles.fill,\n        onLayout: undefined\n      }));\n    }\n  }]);\n\n  return ScrollViewStickyHeader;\n}(React.Component);\n\nvar styles = StyleSheet.create({\n  header: {\n    zIndex: 10\n  },\n  fill: {\n    flex: 1\n  }\n});\nmodule.exports = ScrollViewStickyHeader;","map":{"version":3,"sources":["C:/Users/na2tt/Desktop/homework/Recipe_App/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js"],"names":["AnimatedImplementation","require","React","StyleSheet","View","AnimatedView","createAnimatedComponent","ScrollViewStickyHeader","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","props","_onLayout","event","setState","nativeEvent","layout","y","height","onLayout","child","Children","only","children","inverted","scrollViewHeight","inputRange","outputRange","stickStartPoint","push","collisionPoint","translateY","scrollAnimatedValue","interpolate","style","styles","header","transform","cloneElement","fill","undefined","Component","create","zIndex","flex","module","exports"],"mappings":"AAUA;;;;;;;;;;;;;;;;;;AAEA,IAAMA,sBAAsB,GAAGC,OAAO,CAAC,2CAAD,CAAtC;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,IAAME,UAAU,GAAGF,OAAO,CAAC,6BAAD,CAA1B;;AACA,IAAMG,IAAI,GAAGH,OAAO,CAAC,cAAD,CAApB;;AAIA,IAAMI,YAAY,GAAGL,sBAAsB,CAACM,uBAAvB,CAA+CF,IAA/C,CAArB;;IAuBMG,sB;;;;;;;;;;;;;;;UACJC,K,GAAe;AACbC,MAAAA,QAAQ,EAAE,KADG;AAEbC,MAAAA,OAAO,EAAE,CAFI;AAGbC,MAAAA,YAAY,EAAE,CAHD;AAIbC,MAAAA,iBAAiB,EAAE,MAAKC,KAAL,CAAWD;AAJjB,K;;UAWfE,S,GAAY,UAAAC,KAAK,EAAI;AACnB,YAAKC,QAAL,CAAc;AACZP,QAAAA,QAAQ,EAAE,IADE;AAEZC,QAAAA,OAAO,EAAEK,KAAK,CAACE,WAAN,CAAkBC,MAAlB,CAAyBC,CAFtB;AAGZR,QAAAA,YAAY,EAAEI,KAAK,CAACE,WAAN,CAAkBC,MAAlB,CAAyBE;AAH3B,OAAd;;AAMA,YAAKP,KAAL,CAAWQ,QAAX,CAAoBN,KAApB;;AACA,UAAMO,KAAK,GAAGpB,KAAK,CAACqB,QAAN,CAAeC,IAAf,CAAoB,MAAKX,KAAL,CAAWY,QAA/B,CAAd;;AACA,UAAIH,KAAK,CAACT,KAAN,CAAYQ,QAAhB,EAA0B;AACxBC,QAAAA,KAAK,CAACT,KAAN,CAAYQ,QAAZ,CAAqBN,KAArB;AACD;AACF,K;;;;;;;mCAhBcI,C,EAAW;AACxB,WAAKH,QAAL,CAAc;AAACJ,QAAAA,iBAAiB,EAAEO;AAApB,OAAd;AACD;;;6BAgBoB;AAAA,wBACkB,KAAKN,KADvB;AAAA,UACZa,QADY,eACZA,QADY;AAAA,UACFC,gBADE,eACFA,gBADE;AAAA,wBAE0C,KAAKnB,KAF/C;AAAA,UAEZC,QAFY,eAEZA,QAFY;AAAA,UAEFE,YAFE,eAEFA,YAFE;AAAA,UAEYD,OAFZ,eAEYA,OAFZ;AAAA,UAEqBE,iBAFrB,eAEqBA,iBAFrB;AAGnB,UAAMgB,UAAyB,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,CAAlC;AACA,UAAMC,WAA0B,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAnC;;AAEA,UAAIpB,QAAJ,EAAc;AACZ,YAAIiB,QAAJ,EAAc;AAeZ,cAAIC,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B,gBAAMG,eAAe,GAAGpB,OAAO,GAAGC,YAAV,GAAyBgB,gBAAjD;;AACA,gBAAIG,eAAe,GAAG,CAAtB,EAAyB;AACvBF,cAAAA,UAAU,CAACG,IAAX,CAAgBD,eAAhB;AACAD,cAAAA,WAAW,CAACE,IAAZ,CAAiB,CAAjB;AACAH,cAAAA,UAAU,CAACG,IAAX,CAAgBD,eAAe,GAAG,CAAlC;AACAD,cAAAA,WAAW,CAACE,IAAZ,CAAiB,CAAjB;AAGA,kBAAMC,cAAc,GAClB,CAACpB,iBAAiB,IAAI,CAAtB,IAA2BD,YAA3B,GAA0CgB,gBAD5C;;AAEA,kBAAIK,cAAc,GAAGF,eAArB,EAAsC;AACpCF,gBAAAA,UAAU,CAACG,IAAX,CAAgBC,cAAhB,EAAgCA,cAAc,GAAG,CAAjD;AACAH,gBAAAA,WAAW,CAACE,IAAZ,CACEC,cAAc,GAAGF,eADnB,EAEEE,cAAc,GAAGF,eAFnB;AAID;AACF;AACF;AACF,SAnCD,MAmCO;AAWLF,UAAAA,UAAU,CAACG,IAAX,CAAgBrB,OAAhB;AACAmB,UAAAA,WAAW,CAACE,IAAZ,CAAiB,CAAjB;;AAGA,cAAMC,eAAc,GAAG,CAACpB,iBAAiB,IAAI,CAAtB,IAA2BD,YAAlD;;AACA,cAAIqB,eAAc,IAAItB,OAAtB,EAA+B;AAC7BkB,YAAAA,UAAU,CAACG,IAAX,CAAgBC,eAAhB,EAAgCA,eAAc,GAAG,CAAjD;AACAH,YAAAA,WAAW,CAACE,IAAZ,CAAiBC,eAAc,GAAGtB,OAAlC,EAA2CsB,eAAc,GAAGtB,OAA5D;AACD,WAHD,MAGO;AACLkB,YAAAA,UAAU,CAACG,IAAX,CAAgBrB,OAAO,GAAG,CAA1B;AACAmB,YAAAA,WAAW,CAACE,IAAZ,CAAiB,CAAjB;AACD;AACF;AACF;;AAED,UAAME,UAAU,GAAG,KAAKpB,KAAL,CAAWqB,mBAAX,CAA+BC,WAA/B,CAA2C;AAC5DP,QAAAA,UAAU,EAAVA,UAD4D;AAE5DC,QAAAA,WAAW,EAAXA;AAF4D,OAA3C,CAAnB;AAIA,UAAMP,KAAK,GAAGpB,KAAK,CAACqB,QAAN,CAAeC,IAAf,CAAoB,KAAKX,KAAL,CAAWY,QAA/B,CAAd;AAEA,aACE,oBAAC,YAAD;AACE,QAAA,WAAW,EAAE,KADf;AAEE,QAAA,QAAQ,EAAE,KAAKX,SAFjB;AAGE,QAAA,KAAK,EAAE,CAACQ,KAAK,CAACT,KAAN,CAAYuB,KAAb,EAAoBC,MAAM,CAACC,MAA3B,EAAmC;AAACC,UAAAA,SAAS,EAAE,CAAC;AAACN,YAAAA,UAAU,EAAVA;AAAD,WAAD;AAAZ,SAAnC,CAHT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAIG/B,KAAK,CAACsC,YAAN,CAAmBlB,KAAnB,EAA0B;AACzBc,QAAAA,KAAK,EAAEC,MAAM,CAACI,IADW;AAEzBpB,QAAAA,QAAQ,EAAEqB;AAFe,OAA1B,CAJH,CADF;AAWD;;;;EA/GkCxC,KAAK,CAACyC,S;;AAkH3C,IAAMN,MAAM,GAAGlC,UAAU,CAACyC,MAAX,CAAkB;AAC/BN,EAAAA,MAAM,EAAE;AACNO,IAAAA,MAAM,EAAE;AADF,GADuB;AAI/BJ,EAAAA,IAAI,EAAE;AACJK,IAAAA,IAAI,EAAE;AADF;AAJyB,CAAlB,CAAf;AASAC,MAAM,CAACC,OAAP,GAAiBzC,sBAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nconst AnimatedImplementation = require('../../Animated/src/AnimatedImplementation');\nconst React = require('react');\nconst StyleSheet = require('../../StyleSheet/StyleSheet');\nconst View = require('../View/View');\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\nexport type Props = {\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n  ...\n};\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n  ...\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state: State = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n  };\n\n  setNextHeaderY(y: number) {\n    this.setState({nextHeaderLayoutY: y});\n  }\n\n  _onLayout = event => {\n    this.setState({\n      measured: true,\n      layoutY: event.nativeEvent.layout.y,\n      layoutHeight: event.nativeEvent.layout.height,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  render(): React.Node {\n    const {inverted, scrollViewHeight} = this.props;\n    const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    const translateY = this.props.scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n    const child = React.Children.only(this.props.children);\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        onLayout={this._onLayout}\n        style={[child.props.style, styles.header, {transform: [{translateY}]}]}>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"]},"metadata":{},"sourceType":"script"}