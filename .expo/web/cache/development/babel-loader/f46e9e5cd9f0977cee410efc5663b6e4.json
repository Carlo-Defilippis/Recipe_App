{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _NativeBlobModule = _interopRequireDefault(require(\"./NativeBlobModule\"));\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Blob = require('./Blob');\n\nvar BlobRegistry = require('./BlobRegistry');\n\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n        v = c == 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n\nfunction createBlobCollector(blobId) {\n  if (global.__blobCollectorProvider == null) {\n    return null;\n  } else {\n    return global.__blobCollectorProvider(blobId);\n  }\n}\n\nvar BlobManager = function () {\n  function BlobManager() {\n    (0, _classCallCheck2.default)(this, BlobManager);\n  }\n\n  (0, _createClass2.default)(BlobManager, null, [{\n    key: \"createFromParts\",\n    value: function createFromParts(parts, options) {\n      (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');\n      var blobId = uuidv4();\n      var items = parts.map(function (part) {\n        if (part instanceof ArrayBuffer || global.ArrayBufferView && part instanceof global.ArrayBufferView) {\n          throw new Error(\"Creating blobs from 'ArrayBuffer' and 'ArrayBufferView' are not supported\");\n        }\n\n        if (part instanceof Blob) {\n          return {\n            data: part.data,\n            type: 'blob'\n          };\n        } else {\n          return {\n            data: String(part),\n            type: 'string'\n          };\n        }\n      });\n      var size = items.reduce(function (acc, curr) {\n        if (curr.type === 'string') {\n          return acc + global.unescape(encodeURI(curr.data)).length;\n        } else {\n          return acc + curr.data.size;\n        }\n      }, 0);\n\n      _NativeBlobModule.default.createFromParts(items, blobId);\n\n      return BlobManager.createFromOptions({\n        blobId: blobId,\n        offset: 0,\n        size: size,\n        type: options ? options.type : '',\n        lastModified: options ? options.lastModified : Date.now()\n      });\n    }\n  }, {\n    key: \"createFromOptions\",\n    value: function createFromOptions(options) {\n      BlobRegistry.register(options.blobId);\n      return (0, _extends2.default)(Object.create(Blob.prototype), {\n        data: options.__collector == null ? _objectSpread(_objectSpread({}, options), {}, {\n          __collector: createBlobCollector(options.blobId)\n        }) : options\n      });\n    }\n  }, {\n    key: \"release\",\n    value: function release(blobId) {\n      (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');\n      BlobRegistry.unregister(blobId);\n\n      if (BlobRegistry.has(blobId)) {\n        return;\n      }\n\n      _NativeBlobModule.default.release(blobId);\n    }\n  }, {\n    key: \"addNetworkingHandler\",\n    value: function addNetworkingHandler() {\n      (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');\n\n      _NativeBlobModule.default.addNetworkingHandler();\n    }\n  }, {\n    key: \"addWebSocketHandler\",\n    value: function addWebSocketHandler(socketId) {\n      (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');\n\n      _NativeBlobModule.default.addWebSocketHandler(socketId);\n    }\n  }, {\n    key: \"removeWebSocketHandler\",\n    value: function removeWebSocketHandler(socketId) {\n      (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');\n\n      _NativeBlobModule.default.removeWebSocketHandler(socketId);\n    }\n  }, {\n    key: \"sendOverSocket\",\n    value: function sendOverSocket(blob, socketId) {\n      (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');\n\n      _NativeBlobModule.default.sendOverSocket(blob.data, socketId);\n    }\n  }]);\n  return BlobManager;\n}();\n\nBlobManager.isAvailable = !!_NativeBlobModule.default;\nmodule.exports = BlobManager;","map":{"version":3,"sources":["C:/Users/na2tt/Desktop/homework/Recipe_App/node_modules/react-native/Libraries/Blob/BlobManager.js"],"names":["Blob","require","BlobRegistry","uuidv4","replace","c","r","Math","random","v","toString","createBlobCollector","blobId","global","__blobCollectorProvider","BlobManager","parts","options","NativeBlobModule","items","map","part","ArrayBuffer","ArrayBufferView","Error","data","type","String","size","reduce","acc","curr","unescape","encodeURI","length","createFromParts","createFromOptions","offset","lastModified","Date","now","register","Object","create","prototype","__collector","unregister","has","release","addNetworkingHandler","socketId","addWebSocketHandler","removeWebSocketHandler","blob","sendOverSocket","isAvailable","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nconst Blob = require('./Blob');\nconst BlobRegistry = require('./BlobRegistry');\n\nimport type {BlobData, BlobOptions, BlobCollector} from './BlobTypes';\nimport NativeBlobModule from './NativeBlobModule';\nimport invariant from 'invariant';\n\n/*eslint-disable no-bitwise */\n/*eslint-disable eqeqeq */\n\n/**\n * Based on the rfc4122-compliant solution posted at\n * http://stackoverflow.com/questions/105034\n */\nfunction uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n// **Temporary workaround**\n// TODO(#24654): Use turbomodules for the Blob module.\n// Blob collector is a jsi::HostObject that is used by native to know\n// when the a Blob instance is deallocated. This allows to free the\n// underlying native resources. This is a hack to workaround the fact\n// that the current bridge infra doesn't allow to track js objects\n// deallocation. Ideally the whole Blob object should be a jsi::HostObject.\nfunction createBlobCollector(blobId: string): BlobCollector | null {\n  if (global.__blobCollectorProvider == null) {\n    return null;\n  } else {\n    return global.__blobCollectorProvider(blobId);\n  }\n}\n\n/**\n * Module to manage blobs. Wrapper around the native blob module.\n */\nclass BlobManager {\n  /**\n   * If the native blob module is available.\n   */\n  static isAvailable: boolean = !!NativeBlobModule;\n\n  /**\n   * Create blob from existing array of blobs.\n   */\n  static createFromParts(\n    parts: Array<Blob | string>,\n    options?: BlobOptions,\n  ): Blob {\n    invariant(NativeBlobModule, 'NativeBlobModule is available.');\n\n    const blobId = uuidv4();\n    const items = parts.map(part => {\n      if (\n        part instanceof ArrayBuffer ||\n        (global.ArrayBufferView && part instanceof global.ArrayBufferView)\n      ) {\n        throw new Error(\n          \"Creating blobs from 'ArrayBuffer' and 'ArrayBufferView' are not supported\",\n        );\n      }\n      if (part instanceof Blob) {\n        return {\n          data: part.data,\n          type: 'blob',\n        };\n      } else {\n        return {\n          data: String(part),\n          type: 'string',\n        };\n      }\n    });\n    const size = items.reduce((acc, curr) => {\n      if (curr.type === 'string') {\n        return acc + global.unescape(encodeURI(curr.data)).length;\n      } else {\n        return acc + curr.data.size;\n      }\n    }, 0);\n\n    NativeBlobModule.createFromParts(items, blobId);\n\n    return BlobManager.createFromOptions({\n      blobId,\n      offset: 0,\n      size,\n      type: options ? options.type : '',\n      lastModified: options ? options.lastModified : Date.now(),\n    });\n  }\n\n  /**\n   * Create blob instance from blob data from native.\n   * Used internally by modules like XHR, WebSocket, etc.\n   */\n  static createFromOptions(options: BlobData): Blob {\n    BlobRegistry.register(options.blobId);\n    return Object.assign(Object.create(Blob.prototype), {\n      data:\n        // Reuse the collector instance when creating from an existing blob.\n        // This will make sure that the underlying resource is only deallocated\n        // when all blobs that refer to it are deallocated.\n        options.__collector == null\n          ? {\n              ...options,\n              __collector: createBlobCollector(options.blobId),\n            }\n          : options,\n    });\n  }\n\n  /**\n   * Deallocate resources for a blob.\n   */\n  static release(blobId: string): void {\n    invariant(NativeBlobModule, 'NativeBlobModule is available.');\n\n    BlobRegistry.unregister(blobId);\n    if (BlobRegistry.has(blobId)) {\n      return;\n    }\n    NativeBlobModule.release(blobId);\n  }\n\n  /**\n   * Inject the blob content handler in the networking module to support blob\n   * requests and responses.\n   */\n  static addNetworkingHandler(): void {\n    invariant(NativeBlobModule, 'NativeBlobModule is available.');\n\n    NativeBlobModule.addNetworkingHandler();\n  }\n\n  /**\n   * Indicate the websocket should return a blob for incoming binary\n   * messages.\n   */\n  static addWebSocketHandler(socketId: number): void {\n    invariant(NativeBlobModule, 'NativeBlobModule is available.');\n\n    NativeBlobModule.addWebSocketHandler(socketId);\n  }\n\n  /**\n   * Indicate the websocket should no longer return a blob for incoming\n   * binary messages.\n   */\n  static removeWebSocketHandler(socketId: number): void {\n    invariant(NativeBlobModule, 'NativeBlobModule is available.');\n\n    NativeBlobModule.removeWebSocketHandler(socketId);\n  }\n\n  /**\n   * Send a blob message to a websocket.\n   */\n  static sendOverSocket(blob: Blob, socketId: number): void {\n    invariant(NativeBlobModule, 'NativeBlobModule is available.');\n\n    NativeBlobModule.sendOverSocket(blob.data, socketId);\n  }\n}\n\nmodule.exports = BlobManager;\n"]},"metadata":{},"sourceType":"script"}